
#' Gene signature heatmap
#' 
#' Produces a heatmap of genes signatures for each cell subclass using
#' ComplexHeatmap.
#' 
#' @param x Either a gene signature matrix with genes in rows and cell
#'   subclasses in columns, an object of S3 class 'cellMarkers' generated by
#'   [cellMarkers()], or an object of class 'deconv' generated by
#'   [deconvolute()].
#' @param type Either "subclass" or "group" specifying whether to show the cell
#'   subclass or cell group signature from a 'cellMarkers' or 'deconv' object.
#' @param use_filter Logical whether to show denoised gene signature.
#' @param rank Either "max" or "angle" controlling whether genes (rows) are
#'   ordered in the heatmap by max expression (the default) or lowest angle
#'   (a measure of specificity of the gene as a cell marker).
#' @param scale Character value controlling scaling of genes: "none" for no scaling, "max" to equalise the maximum mean
#'   expression between genes, "sphere" to scale genes to the unit hypersphere
#'   where cell subclasses or groups are dimensions.
#' @param col Vector of colours passed to [ComplexHeatmap::Heatmap()].
#' @param text Logical whether to show values of the maximum cell in each row.
#' @param ... Optional arguments passed to [ComplexHeatmap::Heatmap()].
#' @returns A 'Heatmap' class object.
#' @importFrom grDevices hcl.colors
#' @importFrom grid gpar
#' @importFrom ComplexHeatmap Heatmap pindex
#' @export

signature_heatmap <- function(x,
                              type = c("subclass", "group"),
                              use_filter = NULL,
                              rank = c("max", "angle"),
                              scale = c("none", "max", "sphere"),
                              col = rev(hcl.colors(10, "Greens3")),
                              text = FALSE,
                              ...) {
  type <- match.arg(type)
  rank <- match.arg(rank)
  scale <- match.arg(scale)
  cell_table <- NULL
  if (inherits(x, "deconv")) {
    x <- x$mk
    if (is.null(use_filter)) use_filter <- x$call$use_filter
  }
  if (inherits(x, "cellMarkers")) {
    if (is.null(use_filter)) use_filter <- TRUE
    if (type == "group") {
      gene_signature <- if (use_filter) {x$genemeans_filtered[x$group_geneset, ]
      } else x$genemeans[x$group_geneset, ]
      cell_table <- x$cell_table
    } else {
      gene_signature <- if (use_filter) {x$genemeans_filtered[x$geneset, ]
      } else x$genemeans[x$geneset, ]
      cell_table <- x$cell_table
    }
  } else {
    gene_signature <- x
  }
  whmax <- max.col(gene_signature)
  rmax <- rowMaxs(gene_signature)
  if (rank == "max") {
    ord <- order(whmax, -rmax)
  } else {
    ord <- seq_len(nrow(gene_signature))
  }
  rs <- cell_table[whmax]
  if (scale == "max") gene_signature <- gene_signature / rmax
  if (scale == "sphere") gene_signature <- scaleSphere(gene_signature)
  
  layer_fun <- NULL
  if (text) {
    layer_fun <- function(j, i, x, y, width, height, fill) {
      v <- pindex(gene_signature, i, j)
      ind <- which(v == rowMaxs(gene_signature[i,]))
      if (length(ind) > 0) {
        grid.text(sprintf("%.1f", v[ind]), x[ind], y[ind],
                  gp = gpar(fontsize = 6.5))
      }
    }
  }
  
  Heatmap(gene_signature,
          cluster_rows = FALSE,
          row_order = ord, row_split = rs,
          cluster_columns = FALSE, column_split = cell_table,
          cluster_column_slices = FALSE,
          column_title_gp = gpar(fontsize = 6),
          row_names_gp = gpar(fontsize = 6),
          column_names_rot = 75, column_names_gp = gpar(fontsize = 6),
          row_title_gp = gpar(fontsize = 6),
          col = col,
          layer_fun = layer_fun,
          heatmap_legend_param = list(title='mean'), ...)
}
