
#' Calculate standard error of deconvoluted cell counts
#' 
#' Calculates the standard error of deconvoluted cell counts generated by 
#' [deconvolute()].
#' 
#' This is based on viewing the deconvolution of each sample as a regression
#' \eqn{y = \beta X + \epsilon } in which, \eqn{y} is the gene expression in a
#' sample, \eqn{X} is the gene signature matrix and cell types as regressors and
#' \eqn{\hat{\beta}} are the fitted coefficients which represent the
#' deconvoluted cell counts. Note that here genes are considered as 'samples'.
#' Based on OLS, the standard error of \eqn{\beta} is calculated as:
#' \deqn{\hat{se}(\hat{\beta}) = \sqrt{s^2 (X^T X)^{-1}}}
#' where \eqn{s^2} is the estimate of the sample variance. Instead of using the
#' OLS form, \eqn{(X^T X)^{-1}} is derived from the compensation matrix which
#' has been modified to prevent non-negative \eqn{\hat{\beta}}.
#' @param object A 'deconv' class object generated by [deconvolute()]
#' @returns Matrix of standard errors of cell counts with samples in rows and
#'   cell subclasses in columns.
#' @export
std_error <- function(object) {
  if (!inherits(object, "deconv")) stop("not a 'deconv' class object")
  se <- sqrt(obj$subclass$resvar %*% t(obj$subclass$diag_XTX))
  rownames(se) <- names(obj$subclass$resvar)
  se
}
