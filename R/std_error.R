
#' Calculate standard error of deconvoluted cell counts
#' 
#' Calculates the standard error of deconvoluted cell counts generated by 
#' [deconvolute()].
#' 
#' This is based on viewing the deconvolution of each sample as a regression
#' \eqn{y = \beta X + \varepsilon } in which \eqn{y} is the gene expression in a
#' sample, \eqn{X} is the gene signature matrix with cell types as regressors,
#' and \eqn{\hat{\beta}} are the fitted coefficients which represent the
#' deconvoluted cell counts. Note that here genes are viewed as 'samples'. Based
#' on OLS, the standard errors of \eqn{\hat{\beta}} are calculated as:
#' \deqn{\hat{se}(\hat{\beta_{j}}) = \sqrt{s^2 (X^T X)^{-1}_{jj}}}
#' where \eqn{s^2} is the estimate of the sample variance. Instead of using the
#' exact OLS form, here \eqn{(X^T X)^{-1}} is derived from the compensation
#' matrix which has been regularised to prevent non-negative \eqn{\hat{\beta}}.
#' 
#' @param object A 'deconv' class object generated by [deconvolute()]
#' @returns Matrix of standard errors of cell counts with samples in rows and
#'   cell subclasses in columns.
#' @export
std_error <- function(object) {
  if (!inherits(object, "deconv")) stop("not a 'deconv' class object")
  se <- sqrt(object$subclass$resvar %*% t(object$subclass$diag_XTX))
  rownames(se) <- names(object$subclass$resvar)
  se
}
