
#' Tune deconvolution parameters
#' 
#' Tests a tuning grid of a deconvolution parameter for either [updateMarkers()]
#' (e.g. `expfilter` or `nsubclass`) or [deconvolute()] (e.g. `comp_amount`).
#' 
#' @param cm cellMarkers class object
#' @param test matrix of bulk RNA-Seq to be deconvoluted. Passed to [deconvolute()].
#' @param samples matrix of cell amounts with subclasses in columns and samples
#'   in rows.
#' @param grid Named list of length 1 containing a vector. The name represents
#'   the parameter to be tuned which is an argument in either [updateMarkers()]
#'   or [deconvolute()]. The elements of the vector are the values to be tuned.
#' @param output Character value, either "output" or "percent" specifying which
#'   output from the subclass results element resulting from a call to
#'   [deconvolute()]. This deconvolution result is compared against the actual
#'   sample cell numbers in `samples`, using [Rsq_set()].
#' @param force_intercept Logical whether to force intercept through 0.
#' @param ... Optional arguments passed to [deconvolute()].
#' @returns Dataframe whose columns include: the parameter being tuned, cell
#'   subclass and R squared.
#' @seealso [plot_tune()]
#' @export
tune_deconv <- function(cm, test, samples, grid,
                        output = "output",
                        force_intercept = FALSE, ...) {
  param <- names(grid)
  dots <- list(...)
  if (param %in% names(formals(updateMarkers))) {
    # tune updateMarkers
    message("Tuning ", param, " via updateMarkers() ")
    res <- lapply(grid[[1]], function(i) {
      # message(".", appendLF = FALSE)
      args <- list(object = cm, zz = i)
      names(args)[2] <- param
      cm_update <- do.call("updateMarkers", args) |> suppressMessages()
      fit <- deconvolute(cm_update, test, ...) |> suppressMessages()
      fit_output <- fit$subclass[[output]]
      out <- Rsq_set(samples, fit_output, force_intercept)
      df <- data.frame(zz = i, subclass = names(out), Rsq = out, row.names = NULL)
      colnames(df)[1] <- param
      df
    })
  } else {
    # tune deconvolute
    message("Tuning ", param, " via deconvolute()")
    res <- lapply(grid[[1]], function(i) {
      # message(".", appendLF = FALSE)
      args <- list(mk = cm, test = test, zz = i)
      names(args)[3] <- param
      args <- c(args, dots)
      fit <- do.call("deconvolute", args) |> suppressMessages()
      fit_output <- fit$subclass[[output]]
      out <- Rsq_set(samples, fit_output, force_intercept)
      df <- data.frame(zz = i, subclass = names(out), Rsq = out, row.names = NULL)
      colnames(df)[1] <- param
      df
    })
  }
  
  res <- do.call(rbind, res)
  # m <- tapply(res$Rsq, res[, 1], mean, na.rm = TRUE)
  # w <- which.max(m)
  # message(" best ", param, " = ", grid[[1]][w])
  res
}


#' Plot tuning curves
#' 
#' Produces a ggplot2 plot of R-squared values generated by [tune_deconv()].
#' 
#' @param res Dataframe of tuning results generated by [tune_deconv()].
#' @param title Character value for the plot title.
#' @returns ggplot2 scatter plot.
#' @importFrom ggplot2 geom_line ggtitle mean_se stat_summary theme_bw
#' @export
plot_tune <- function(res, title = "") {
  wx <- colnames(res)[1]
  ggplot(res, aes(x = .data[[wx]], y = .data$Rsq, color = .data$subclass)) +
    geom_line() +
    geom_point() +
    stat_summary(fun.data = mean_se, geom = "errorbar", col = "black", width = 0.02) +
    stat_summary(fun = mean, geom = "point", col = "black") +
    ggtitle(title) +
    theme_bw() +
    theme(plot.title = element_text(size = 10),
          axis.text = element_text(colour = "black"))
}


#' @export
tune_deconv2 <- function(cm, test, samples, grid,
                         output = "output",
                         force_intercept = FALSE, ...) {
  params <- names(grid)
  arg_set1 <- names(formals(updateMarkers))
  arg_set2 <- names(formals(deconvolute))
  if (any(!params %in% c(arg_set1, arg_set2)))
    stop("unknown tuning parameter in `grid`")
  w1 <- which(params %in% arg_set1)
  w2 <- which(params %in% arg_set2)
  grid2 <- if (length(w2) > 0) expand.grid(grid[w2]) else NULL
  message("Tuning parameters: ", paste(params, collapse = ", "))
  
  if (length(w1) > 0) {
    grid1 <- expand.grid(grid[w1])
    res <- lapply(seq_len(nrow(grid1)), function(i) {
      cat(".")
      args <- list(object = cm)
      grid1_row <- grid1[i, , drop = FALSE]
      args <- c(args, grid1_row)
      cm_update <- do.call("updateMarkers", args) |> suppressMessages()
      df2 <- tune_dec(cm_update, test, samples, grid2, output,
                      force_intercept = FALSE, ...)
      data.frame(grid1_row, df2, row.names = NULL)
    })
    res <- do.call(rbind, res)
  } else {
    # null grid1
    if (is.null(grid2)) stop("No parameters to tune")
    res <- tune_dec(cm, test, samples, grid2, output, force_intercept = FALSE,
                    ...)
  }
  
  mres <- aggregate(res$Rsq, by = res[, params], FUN = mean)
  colnames(mres)[which(colnames(mres) == "x")] <- "mean.Rsq"
  w <- which.max(mres$mean.Rsq)
  best_tune <- mres[w, ]
  cat("\nBest tune:\n")
  print(best_tune, row.names = FALSE, digits = max(3, getOption("digits")-3),
        print.gap = 2L)
  
  res
}


tune_dec <- function(cm, test, samples, grid2, output, force_intercept,
                     ...) {
  if (is.null(grid2)) {
    fit <- deconvolute(cm, test, ...) |> suppressMessages()
    fit_output <- fit$subclass[[output]]
    out <- Rsq_set(samples, fit_output, force_intercept)
    df <- data.frame(subclass = names(out), Rsq = out, row.names = NULL)
    return(df)
  }
  # loop grid2
  res <- lapply(seq_len(nrow(grid2)), function(i) {
    dots <- list(...)
    grid2_row <- grid2[i, , drop = FALSE]
    args <- list(mk = cm, test = test)
    args <- c(args, grid2_row)
    if (length(dots)) args[names(dots)] <- dots
    fit <- do.call("deconvolute", args) |> suppressMessages()
    fit_output <- fit$subclass[[output]]
    out <- Rsq_set(samples, fit_output, force_intercept)
    df <- data.frame(grid2_row, subclass = names(out), Rsq = out,
                     row.names = NULL)
  })
  do.call(rbind, res)
}


