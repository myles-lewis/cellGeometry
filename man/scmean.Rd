% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scmean.R
\name{scmean}
\alias{scmean}
\title{Single-cell mean log gene expression across cell types}
\usage{
scmean(
  x,
  celltype,
  FUN = logmean,
  postFUN = NULL,
  verbose = TRUE,
  sliceLim = 8,
  cores = 1L
)
}
\arguments{
\item{x}{matrix, sparse matrix or DelayedMatrix of raw counts with genes in
rows and cells in columns.}

\item{celltype}{a vector of cell subclasses or types whose length matches the
number of columns in \code{x}. It is coerced to a factor. \code{NA} are tolerated and
the matching columns in \code{x} are skipped.}

\item{FUN}{Function for applying mean. When applied to a matrix of count
values, this must return a vector. Recommended options are \code{logmean} (the
default) or \code{trimmean}.}

\item{postFUN}{Optional function to be applied to whole matrix after mean has
been calculated, e.g. \code{log2s}.}

\item{verbose}{Logical, whether to print messages.}

\item{cores}{Integer, number of cores to use for parallelisation using
\code{mclapply()}. Parallelisation is not available on windows. Warning:
parallelisation has increased memory requirements.}

\item{big}{Logical, whether to invoke slicing of \code{x} into rows. This is
invoked automatically if \code{x} is a large matrix with >2^31 elements.}

\item{sliceSize}{Integer, number of rows of \code{x} to use in each slice if
\code{big = TRUE}.}
}
\value{
a matrix of mean log2 gene expression across cell types with genes
in rows and cell types in columns.
}
\description{
Workhorse function which takes as input a scRNA-Seq gene expression matrix
such as embedded in a Seurat object, calculates log2(counts +1) and averages
gene expression over a vector specifying cell subclasses or cell types. Very
large matrices are handled by slicing rows into blocks to avoid excess memory
requirements.
}
\details{
We find a significant speed up with \code{cores = 2}, which is almost twice as
fast as single core, but not much to be gained beyond this possibly due to
limits on memory traffic. The main speed up is in assigning the decompression
of a block from the sparse matrix to more than 1 core. Increasing \code{sliceSize}
also gives a speed up, but the limit on \code{sliceSize} is that the number of
elements manipulated in each block (i.e. \code{sliceSize} x number of cells in a
given subclass/group) must be kept below the long vector limit of 2^31
(around 2e9). Increasing \code{cores} and/or \code{sliceSize} requires substantial
amounts of spare RAM.

Mean functions which can be applied by setting \code{FUN} include \code{logmean} (the
default) which applies row means to log2(counts+1), or \code{trimmean} which
calculates the trimmed mean of the counts after top/bottom 5\% of values have
been excluded. Alternatively \code{FUN = rowMeans} calculates the arithmetic mean
of counts.

If \code{FUN = trimmean} or \code{rowMeans}, \code{postFUN} needs to be set to \code{log2s} which
is a simple function which applies log2(x+1).
}
\seealso{
\code{\link[=scapply]{scapply()}} which is a more general version which can apply any
function to the matrix. \code{\link[=logmean]{logmean}},
\code{\link[=trimmean]{trimmean}} are options for controlling the type of
mean applied.
}
\author{
Myles Lewis
}
